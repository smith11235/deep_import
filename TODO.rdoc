---
belongs_to helpers:
- *** remove dfs logic
	- start with parent method
  - get associations task working

	- api: 
		- random assignment:
			- child.parent = random_parent 
				- set corresponding deep_import_child.deep_import_parent_id = parent.deep_import_id
				- hook into the 'association' call
					- based on behavior of belongs_to
			- define in model_logic:
				Config.models[ self ].belongs_to.each do |belongs_to_class|
					# preserve the currently configured functionality under a new method name
					# tweak rails: http://errtheblog.com/posts/18-accessor-missing
					belongs_to_method = "#{belongs_to_class.to_s.underscore}=".to_sym
					inner_belongs_to_method = "active_record_#{belongs_to_method}".to_sym
			  	send :alias_method, inner_belongs_to_method, belongs_to_method 

					# http://www.vitarara.org/cms/ruby_metaprogamming_declaratively_adding_methods_to_a_class
				 	send :define_method, belongs_to_method do |belongs_to_instance| :
						ModelsCache.set_association( belongs_to_instance, self )
						send inner_belongs_to_method, belongs_to_instance
					end
		
		- save: raise error, or print warning silently depending on setting

		- nested construction:
			- child = parent.children.build
				- hook into has_many/one association helpers
				- call belongs_to logic

			- child = parent.children.create 
				- call build
					- override method definition on model

			- http://errtheblog.com/posts/18-accessor-missing
			- metaprogramming: http://yehudakatz.com/2009/11/15/metaprogramming-in-ruby-its-all-about-the-self/

---
Teardown:
	- add specs for it

---
batch id as part of deep_import_id field:
- get a process id
- set deep_import_id = "#{process_id}.#{id}"
- commit: scope all queries to this process_id prefix

---
Model Flags:
_polymorphic:

---
Config File:
	- spec: 
		- test for invalid config files
		- test for missing config file

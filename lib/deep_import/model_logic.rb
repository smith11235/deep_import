module DeepImport 
=begin
  http://guides.rubyonrails.org/association_basics.html#association-extensions
  https://gist.github.com/bigfive/1399762
  meta-programming reference: http://www.vitarara.org/cms/ruby_metaprogamming_declaratively_adding_methods_to_a_class
  on tweaking rails: http://errtheblog.com/posts/18-accessor-missing
  on rails model callbacks: http://guides.rubyonrails.org/active_record_validations_callbacks.html#after_initialize-and-after_find
      # we are overriding all appropriate methods generated by:
      # http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html
      # has_many, has_one, belongs_to association methods
=end
  module ModelLogic

    def self.included(base) # :nodoc:
      # TODO: already initialized safety check

      DeepImport.logger.info "DeepImport::ModelLogic: Initializing: #{base}".green

      base.class_eval do
        # https://littlelines.com/blog/2018/01/31/replace-alias-method-chain
        prepend DeepImportOverrideMethods # more specialized active record handlers
        after_initialize :deep_import_after_initialize

        belongs_to_associations = DeepImport::Config.models.fetch( base ).fetch( :belongs_to )
        belongs_to_associations.keys.each do |belongs_to_class|
          other_name = belongs_to_class.to_s.underscore
          # for belongs to: self.other=, self.build_other(params), self.create_other(params)
          DeepImportOverrideMethods.define_assigns other_name
          DeepImportOverrideMethods.define_build other_name
          DeepImportOverrideMethods.define_create other_name

          # TODO: on {belongs_to_class}.{base.pluralize}.(build|create(!))
        end
      end
    end

    def deep_import_after_initialize
      return unless DeepImport.importing? # only during imports
      # Assign new deep import id if this is a new record
      return unless self.new_record? 
      return unless self.deep_import_id.nil? 

      DeepImport::ModelsCache.add(self) # add to cache/set id
      # TODO: check for associations (Model.new other_model: om)
    end

    module DeepImportOverrideMethods

      def self.define_assigns other_name
        # aka: child.parent = parent
        send :define_method, "#{other_name}=".to_sym do |other_instance|
          super(other_instance) # call original self.other_name =
          DeepImport::ModelsCache.set_association_on(self, other_instance) if DeepImport.importing? 
        end
      end

      def self.define_build other_name
        # aka: child.build_parent(attrs)
        send :define_method, "build_#{other_name}".to_sym do |attributes = {}| 
          # TODO: could do "attributes.merge self.class => self"
          other_instance = super(attributes) # call original, return new instance
          # in belongs to, we need to set association id on this end, reuse assigns helper
          other_method = "#{other_instance.class.to_s.underscore}=".to_sym
          send other_method, other_instance
          return other_instance
        end
      end

      def self.define_create other_name
        # aka: child.create_parent(!)
        [ "", "!" ].each do |exclamation|
          method_name = "create_#{other_name}#{exclamation}".to_sym
          send :define_method, method_name do |attributes = {}| 
            if DeepImport.importing?
              raise "DeepImport: create_{model}(!) disabled"
              # pass on_save: :noop to ignore" 
              # TODO: provide ':on_belongs_to_create_other => :build_other' to DeepImport.import to override"
              # ^ redirect create to build (automatically or as option)
            else
              super
            end
          end
        end
      end

      def save
        deep_import_safety_check { super }
      end

      def save!
        deep_import_safety_check { super }
      end

      private

      def deep_import_safety_check
        if !DeepImport.importing?
          yield # not in import block, do standard active record call
        elsif DeepImport.raise_error? 
          raise "DeepImport: 'save' called within import block - change code or pass 'on_save: :noop'"
        else
          # :noop - ignore call, keep processing
        end
      end
    end
  end

end

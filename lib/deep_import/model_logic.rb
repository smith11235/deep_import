module DeepImport 
=begin
  http://guides.rubyonrails.org/association_basics.html#association-extensions
  https://gist.github.com/bigfive/1399762
  meta-programming reference: http://www.vitarara.org/cms/ruby_metaprogamming_declaratively_adding_methods_to_a_class
  on tweaking rails: http://errtheblog.com/posts/18-accessor-missing
  on rails model callbacks: http://guides.rubyonrails.org/active_record_validations_callbacks.html#after_initialize-and-after_find
      # we are overriding all appropriate methods generated by:
      # http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html
      # has_many, has_one, belongs_to association methods


  # New Blogs
  # https://littlelines.com/blog/2018/01/31/replace-alias-method-chain
=end


  # Common safety guard for Save methods vs No-Op option 

  # TODO: need to add deepimport to model defs
  # Parent
  #   include DeepImport::Importable
  #   has_many :children, extend: DeepImport::HasMany
  #   has_many :in_laws, as: :relation, extend: DeepImport::HasMany
  # InLaw
  #   include DeepImport::Importable
  #   belongs_to :relation, polymorphic: true, extend: DeepImport::BelongsTo
  # 

  module ModelLogic

    def self.included(base) # :nodoc:
      # TODO: already initialized safety check
      base.class_eval do
        # TODO: migrate this to extend: o
        belongs = DeepImport::Config.belongs_to(self)
        if belongs.size > 0
          # TODO: migrate this to: belongs_to:
          prepend BelongsTo 
          belongs.each do |other_name|
            BelongsTo.define_assigns other_name # self.other=
            BelongsTo.define_build other_name   # self.build_other(attrs)
            BelongsTo.define_create other_name  # self.create_other[!](attrs)
          end
        end
      end
    end

    module BelongsTo

      def self.define_assigns other_name
        # aka: child.parent = parent
        send :define_method, "#{other_name}=".to_sym do |other_instance|
          super(other_instance) # call original self.other_name =
          return other_instance if deep_import_id.nil? || !DeepImport.importing?
          # ^ bulk assignment calls 'other=', before deep import id is created....
          # ignore association tracking until an id has been assigned, then add tracking (from after_initialize)
          DeepImport::ModelsCache.set_association_on(self, other_instance) 
          other_instance
        end
      end

      def self.define_build other_name
        # aka: child.build_parent(attrs)
        send :define_method, "build_#{other_name}".to_sym do |attributes = {}| 
          # TODO: potentially do "attributes.merge self.class => self", rather than needing import block
          other_instance = super(attributes) 
          if DeepImport.importing? # tricker deep import association tracking
            other_method = "#{other_instance.class.to_s.underscore}=".to_sym
            send other_method, other_instance
          end
          return other_instance
        end
      end

      def self.define_create other_name
        # aka: child.create_parent(!)
        [ "", "!" ].each do |exclamation|
          method_name = "create_#{other_name}#{exclamation}".to_sym
          send :define_method, method_name do |attributes = {}| 
            if DeepImport.allow_commit?
              super(attributes)
            else # redirect to build
              build_method = __method__.to_s.gsub(/create/, 'build').gsub(/!/, '')
              send(build_method, attributes)
            end
          end
        end
      end
    end
  end

end

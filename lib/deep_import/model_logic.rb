module DeepImport 
=begin
	http://guides.rubyonrails.org/association_basics.html#association-extensions
	https://gist.github.com/bigfive/1399762
	meta-programming reference: http://www.vitarara.org/cms/ruby_metaprogamming_declaratively_adding_methods_to_a_class
	on tweaking rails: http://errtheblog.com/posts/18-accessor-missing
	on rails model callbacks: http://guides.rubyonrails.org/active_record_validations_callbacks.html#after_initialize-and-after_find
=end

	def self.add_model_logic_to( model_class )
		model_class.class_eval do
			# pull in the deep import logic
			include DeepImport::ModelLogicEnhancements 
		end

		model_class.setup # run the setup method exposed by ModelLogicEnhancements

		model_class.class_eval do
			# todo: remove this
			def self.parent_class
				DeepImport::Config.parent_class_of self
			end
		end	

	end

	module ModelLogicEnhancements

		def self.included(base) # :nodoc:
			base.extend ClassMethods
		end

		module ClassMethods
			def setup
				send :attr_accessible, :deep_import_id # expose the deep_import_id methods

				setup_after_initialization_callback

				setup_association_logic
			end

			def setup_association_logic
				DeepImport::Config.models[ self ][:belongs_to].each do |belongs_to_class|
					setup_belongs_to_association_for( belongs_to_class )
				end
				DeepImport::Config.models[ self ][:has_one].each do |has_one_class|
					setup_has_one_association_for( has_one_class )
				end
				DeepImport::Config.models[ self ][:has_many].each do |has_many_class|
					setup_has_many_association_for( has_many_class )
				end
			end

			# we are overriding all appropriate methods generated by:
			# http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html
			# has_many, has_one, belongs_to association methods

=begin
has_many:
	endable:
	- others.build  
	- others.create(!) # use build
	- others.push 

	- others<< 
	- others.concat 

	- others=(other,other,...) 

	disable: # this is a load environment, these are disabled, learn to use it, see docs
	- other_ids=   
	- clear 
	- delete 
	- delete_all 
	- destroy
	- destroy_all
	- reset
=end
			def setup_has_many_association_for( has_many_class )
				puts "Setup #{self}.has_many #{has_many_class}".yellow
				# all these methods have ownership, but set the deep import on the belongs to class
				# similar to  :has_one
				# setup_method_others_dot_build( has_many_class )
			end


=begin
	helper methods for has_many associations
=end
	def setup_method_others_dot_build( other_class )
		override_method( "#{other_class.to_s.underscore.pluralize}.build" ) do |attributes = {}| 
			# build a new method with this method
			other_instance = send inner_method_name, attributes # call the orriginal logic to run normal logic

 	  	DeepImport::ModelsCache.set_association_on( other_instance, self )
			return other_instance

		end
	end

	def override_method( method_name, &method_logic_block )
		method_name = method_name.to_sym if method_name.is_a? String # usage helper
		# validation
		raise "Method Name is not a symbol or string: class: #{method_name.class} value: #{method_name.to_yaml}" unless method_name.is_a? Symbol
		# now we're going to
		# alias the method to a new name
		# and redefine the method name to use the passed in block

		# question: is this exposed to the block here?

		# alias this method to a new method name
		inner_method_name =	method_override_for( method_name ) 

	  # define the new method logic passed in the block
		send :define_method, method_name, method_logic_block
	end


=begin
has_one AND belongs_to
	endabled:
	- other= instance # done
	- build_other( attributes = {} ) # 
	- create_other( attributes = {} ) # disable # done
	- create_other!( attributes = {} ) # disable # done
=end

			def	setup_has_one_association_for( other_class )
				setup_method_other = other_class, :has_one 
				setup_method_create_other( other_class, :has_one  ) # also does create_other!
				setup_method_build_other( other_class, :has_one  ) 
			end

			def	setup_belongs_to_association_for( other_class )
				setup_method_other = other_class, :belongs_to 
				setup_method_create_other( other_class, :belongs_to  ) # also does create_other!
				setup_method_build_other( other_class, :belongs_to  ) 
			end


=begin
	Method construction methods that create the
	- has_one
	- belongs_to
	association methods
=end

				#- belongs_to
				# self.other = 
				# self.create_other
				# self.build_other

			def setup_method_build_other( other_class, association_type )
				method_name = "build_#{other_class.to_s.underscore}".to_sym
				# alias this method to a new method name
				inner_method_name =	method_override_for( method_name ) 
				# define the new method logic based on the direction we're looking
				case association_type
				when :has_one
					send :define_method, method_name do |attributes = {}| 
						other_instance = send inner_method_name, attributes # call the orriginal logic to run normal logic
						DeepImport::ModelsCache.set_association_on( other_instance, self )
						return other_instance
					end
				when :belongs_to
					send :define_method, method_name do |attributes = {}| 
						other_instance = send inner_method_name, attributes # call the orriginal logic to run normal logic
						DeepImport::ModelsCache.set_association_on( self, other_instance )
						return other_instance
					end
				else
					raise "Unknown association type: #{association_type}"
				end
			end

			def setup_method_create_other( other_class, association_type )
				# get the properly formatted method name
				[ "", "!" ].each do |exclamation|
					method_name = "create_#{other_class.to_s.underscore}#{exclamation}".to_sym
					# alias this method to a new method name
					inner_method_name =	method_override_for( method_name ) 

					# DISABLED: these tasks are currently disabled
					# define the new method logic based on the direction we're looking
					case association_type
					when :has_one
						send :define_method, method_name do |attributes = {}| 
							raise "DeepImport has disabled this method, please use .build_#{self.class.to_s.underscore} instead"
						end
					when :belongs_to
						send :define_method, method_name do |attributes = {}| 
							raise "DeepImport has disabled this method, please use .build_#{self.class.to_s.underscore} instead"
						end
					else
						raise "Unknown type: #{association_type}"
					end
				end
			end

			def setup_method_other=( other_class, association_type )
				# get the properly formatted method name
				method_name = "#{other_class.to_s.underscore}=".to_sym
				# alias this method to a new method name
				inner_method_name =	method_override_for( method_name ) 
				# define the new method logic based on the direction we're looking
				case association_type
				when :has_one
					send :define_method, method_name do |other_instance| 
						send inner_method_name, other_instance # call the orriginal logic to save run normal logic
						DeepImport::ModelsCache.set_association_on( other_instance, self ) # reversed from belongs_to arrangement, so the id gets assigned on the correct model
					end
				when :belongs_to
					send :define_method, method_name do |other_instance| 
						send inner_method_name, other_instance # call the orriginal logic to save run normal logic
						DeepImport::ModelsCache.set_association_on( self, other_instance  ) # setup deep import id tracking 
					end
				else
					raise "Unknown type: #{association_type}"
				end
			end

			# method setup helper, alias's the currently constructed method to a new name and returns the name
			def method_override_for( method_name )
				# use a standard prefix before the original method name as the overridden method
				inner_method_name = "renamed_by_deep_import_#{method_name}=".to_sym

				# copy the standard method to the new name so that we can redefine the standard method
				send :alias_method, inner_method_name, method_name 

				# question: does this check to see if the expected method exists?
				# question: does this check to see if the planned newly named method exists?

				return inner_method_name # return the inner name for use
			end

			def setup_after_initialization_callback 
				# add the after initialization callback method
				send :define_method, :deep_import_after_initialize do
					# this is called after new and find, we want to check if this really is new
					return unless self.new_record? # if its a preexisting model
					return unless self.deep_import_id.nil? # if it already has a deep import id
					return unless ENV["disable_deep_import"].nil? # if deep_import functionality is disabled
					# add this new instance to the cache
					DeepImport::ModelsCache.add( self )
				end
				# add a callback to 'deep_import_after_initialize' after each model initialization
				send :after_initialize, :deep_import_after_initialize
			end

		end

	end

end

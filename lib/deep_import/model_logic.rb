module DeepImport 
=begin
	http://guides.rubyonrails.org/association_basics.html#association-extensions
	https://gist.github.com/bigfive/1399762
	meta-programming reference: http://www.vitarara.org/cms/ruby_metaprogamming_declaratively_adding_methods_to_a_class
	on tweaking rails: http://errtheblog.com/posts/18-accessor-missing
	on rails model callbacks: http://guides.rubyonrails.org/active_record_validations_callbacks.html#after_initialize-and-after_find
			# we are overriding all appropriate methods generated by:
			# http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html
			# has_many, has_one, belongs_to association methods
=end
	module ModelLogic

		def self.included(base) # :nodoc:
      # TODO: cleanup
      raise "Already extended" unless base.column_names.include? 'deep_import_id'
			#raise "It appears as if #{base} has already been extended by DeepImport, this should only be done once" if base.accessible_attributes.to_a.include? 'deep_import_id'

			DeepImport.logger.info "Adding DeepImport::ModelLogic to #{base}".green
			# add the new methods to this model class in question
			base.extend ClassSetupMethods 

      # base.setup_deep_import
      # TODO: use ^ - refactor below to prepend/DeepImportMethods

			# now setup the basic deep import model tracking
			base.setup_deep_import_id
			base.setup_after_initialization_callback
			base.modify_save
			# and then the belongs_to associations
			belongs_to_associations = DeepImport::Config.models.fetch( base ).fetch( :belongs_to )
			belongs_to_associations.keys.each do |belongs_to_class|
				base.setup_belongs_to_association_for( belongs_to_class )
			end
		end


    module DeepImportMethods
      # https://littlelines.com/blog/2018/01/31/replace-alias-method-chain
      def save
        # TODO
      end
      def save!
        # TODO
      end
    end


		module ClassSetupMethods
      def setup_deep_import
        # TODO: use this for better Rails futurization
        send :prepend, DeepImportMethods
      end

			def setup_deep_import_id 
        # TODO: is this needed in Rails 4+
        # I think this can be removed
				#send :attr_accessible, :deep_import_id # expose the deep_import_id methods
			end

			def modify_save
				[ "", "!" ].each do |ending|
					method_name = "save#{ending}".to_sym
					deep_import_method = "save_with_deep_import#{ending}".to_sym
					without_method = "save_without_deep_import#{ending}".to_sym
					case DeepImport.import_options[ :on_save ] 
					when :raise_error # Better - Prevents mistaken code
						send :define_method, deep_import_method do
							if DeepImport.importing?
								raise "disabled by DeepImport, provide ':on_save => :noop' to DeepImport.import to override"
							else
                # TODO: super - without_method_name is bad code here
								send without_method	
							end
						end
					when :noop # Ok - Allows reused code between web controller/deep import jobs
						send :define_method, deep_import_method do
							if DeepImport.importing?
								# noop
							else
                # TODO: super - without_method_name is bad code here
								send without_method	
							end
						end
					end

          # send :alias_method_chain,  method_name, :deep_import # Deprecated
          send :alias_method, without_method, method_name # original source method
					send :alias_method, method_name, deep_import_method # new intercept method
				end
			end

			def	setup_belongs_to_association_for( other_class )
				other_name = other_class.to_s.underscore
				setup_belongs_to_other( other_name )
				setup_method_build_other( other_name )
				setup_method_create_other( other_name )

			end

			def setup_method_build_other( other_name )
				method_name = "build_#{other_name}".to_sym
				deep_import_method_name = "#{method_name}_with_deep_import".to_sym
				without_method_name = "#{method_name}_without_deep_import".to_sym

				# define the new method logic based on the direction we're looking
				send :define_method, deep_import_method_name do |attributes = {}| 
					other_instance = send without_method_name, attributes # call the orriginal logic to run normal logic

					other_method = "#{other_instance.class.to_s.underscore}=".to_sym
					send other_method, other_instance

					return other_instance
				end

				# send :alias_method_chain,  method_name, :deep_import # DEPRECATED
        send :alias_method, without_method_name, method_name # original source method
			  send :alias_method, method_name, deep_import_method_name # new intercept method
			end

			def setup_method_create_other( other_name )
				# get the properly formatted method name
				[ "", "!" ].each do |exclamation|
					method_name = "create_#{other_name}#{exclamation}".to_sym
					# new method names: deep_import logic, original logic
					deep_import_method_name = "create_#{other_name}_with_deep_import#{exclamation}".to_sym
					without_method_name = "create_#{other_name}_without_deep_import#{exclamation}".to_sym

					send :define_method, deep_import_method_name do |attributes = {}| 
						if DeepImport.importing?
							raise "disabled by DeepImport" #, provide ':on_belongs_to_create_other => :build_other' to DeepImport.import to override"
						else
							send without_method_name
						end
					end

					#send :alias_method_chain,  method_name, :deep_import # DEPRECATED
          send :alias_method, without_method_name, method_name # original source method
					send :alias_method, method_name, deep_import_method_name # new intercept method
				end
			end


			def setup_belongs_to_other( other_name )
				# method we are enhancing
				method_name = "#{other_name}=".to_sym
				# new method names: deep_import logic, original logic
				deep_import_method_name = "#{other_name}_with_deep_import=".to_sym
				without_method_name = "#{other_name}_without_deep_import=".to_sym

				# define the deep import method
				send :define_method, deep_import_method_name do |other_instance| 
					send without_method_name, other_instance # original logic 
					DeepImport::ModelsCache.set_association_on( self, other_instance  ) if DeepImport.importing? 
				end

				# send :alias_method_chain,  method_name, deep_import_method_name # 
        send :alias_method, without_method_name, method_name # original source method
			  send :alias_method, method_name, deep_import_method_name # new intercept method
			end

			def setup_after_initialization_callback 
				# add the after initialization callback method
				send :define_method, :deep_import_after_initialize do
					return unless DeepImport.importing?
					# this is called after new and find, we want to check if this really is new
					return unless self.new_record? # if its a preexisting model
					return unless self.deep_import_id.nil? # if it already has a deep import id

					# add this new instance to the cache
					DeepImport::ModelsCache.add( self )
				end

				# add a callback to 'deep_import_after_initialize' after each model initialization
				send :after_initialize, :deep_import_after_initialize
			end

		end

	end

end

module DeepImport 
=begin
	http://guides.rubyonrails.org/association_basics.html#association-extensions
	https://gist.github.com/bigfive/1399762
	meta-programming reference: http://www.vitarara.org/cms/ruby_metaprogamming_declaratively_adding_methods_to_a_class
	on tweaking rails: http://errtheblog.com/posts/18-accessor-missing
	on rails model callbacks: http://guides.rubyonrails.org/active_record_validations_callbacks.html#after_initialize-and-after_find
			# we are overriding all appropriate methods generated by:
			# http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html
			# has_many, has_one, belongs_to association methods
=end
	module ModelLogic
		def self.included(base) # :nodoc:
			puts "Adding DeepImport::ModelLogic to #{base}"
			base.extend ClassMethods

			# now setup the basic deep import model tracking
			base.setup_deep_import_id
			base.setup_after_initialization_callback
			# and then the belongs_to associations
			belongs_to_associations = DeepImport::Config.models.fetch( base ).fetch( :belongs_to )
			belongs_to_associations.keys.each do |belongs_to_class|
				base.setup_belongs_to_association_for( belongs_to_class )
			end
		end

		module ClassMethods
			def setup_deep_import_id 
				send :attr_accessible, :deep_import_id # expose the deep_import_id methods
			end

			def	setup_belongs_to_association_for( other_class )
				other_name = other_class.to_s.underscore

				# method we are enhancing
				method_name = "#{other_name}=".to_sym
				# new method names: deep_import logic, original logic
				deep_import_method_name = "#{other_name}_with_deep_import=".to_sym
				without_method_name = "#{other_name}_without_deep_import=".to_sym
				
				# define the deep import method
				send :define_method, deep_import_method_name do |other_instance| 
					send without_method_name, other_instance # original logic 
					DeepImport::ModelsCache.set_association_on( self, other_instance  ) if DeepImport.importing? 
				end

				send :alias_method_chain,  method_name, :deep_import
			end

			def setup_after_initialization_callback 
				# add the after initialization callback method
				send :define_method, :deep_import_after_initialize do
					return unless DeepImport.importing?
					# this is called after new and find, we want to check if this really is new
					return unless self.new_record? # if its a preexisting model
					return unless self.deep_import_id.nil? # if it already has a deep import id

					# add this new instance to the cache
					DeepImport::ModelsCache.add( self )
				end

				# add a callback to 'deep_import_after_initialize' after each model initialization
				send :after_initialize, :deep_import_after_initialize
			end

		end

	end

end
